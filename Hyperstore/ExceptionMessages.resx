<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AlreadyInitialized" xml:space="preserve">
    <value>Already initialized</value>
  </data>
  <data name="AwaitInSessionIsNotAllowed" xml:space="preserve">
    <value>Await in session is not allowed</value>
  </data>
  <data name="CannotCreateNestedSessionInDisposingSession" xml:space="preserve">
    <value>You can't create a nested session in a disposing session</value>
  </data>
  <data name="CannotSetCategoryOnImplicitConstraint" xml:space="preserve">
    <value>You can't set a category on an implicit constraint</value>
  </data>
  <data name="CantExtendDomainModel_GraphAdapter" xml:space="preserve">
    <value>Can't extend domain model. Graph adapter</value>
  </data>
  <data name="CantRemoveSchemaElementSchemaIsImmutable" xml:space="preserve">
    <value>You can't remove a schema element. Schema is immutable</value>
  </data>
  <data name="CantUseElementFromUnloadedDomain" xml:space="preserve">
    <value>Can't use an element from an unloaded domain</value>
  </data>
  <data name="CompositionAlreadyDone" xml:space="preserve">
    <value>Composition already done</value>
  </data>
  <data name="CreatePropertyWithIdForMetaclassFormat" xml:space="preserve">
    <value>Create property {0} with id {1} for metaclass {2}</value>
    <comment>{0} property name
{1} id
{2} id</comment>
  </data>
  <data name="CriticalErrorMaybeAwaitInSession" xml:space="preserve">
    <value>Critical error - Maybe because await in your session</value>
  </data>
  <data name="DefaultConfigurationIsNull" xml:space="preserve">
    <value>Default configuration is null</value>
  </data>
  <data name="DependencyResolverMustInheritFromDefaultDependencyResolver" xml:space="preserve">
    <value>DependencyResolver must inherit from DefaultDependencyResolver</value>
  </data>
  <data name="Diagnostic_ApplicationError" xml:space="preserve">
    <value>Application error</value>
  </data>
  <data name="Diagnostic_CommandAborted" xml:space="preserve">
    <value>Command aborted</value>
  </data>
  <data name="Diagnostic_ConstraintsProcessError" xml:space="preserve">
    <value>Constraints process error</value>
  </data>
  <data name="Diagnostic_ErrorInPersistenceAdapter" xml:space="preserve">
    <value>Error in persistence adapter</value>
  </data>
  <data name="Diagnostic_ErrorProcessingCommandFormat" xml:space="preserve">
    <value>Error when processing command {0}</value>
    <comment>{0} command name</comment>
  </data>
  <data name="Diagnostic_ErrorWhenProcessingAfterInterceptorforCommandFormat" xml:space="preserve">
    <value>Error when processing after interceptor {0} for command {1}</value>
    <comment>{0} interceptor type name
{1} command name</comment>
  </data>
  <data name="Diagnostic_ErrorWhenProcessingBeforeInterceptorforCommandFormat" xml:space="preserve">
    <value>Error when processing before interceptor {0} for command {1}</value>
    <comment>{0} interceptor type name
{1} command name</comment>
  </data>
  <data name="Diagnostic_ErrorWhenProcessingErrorInterceptorforCommandFormat" xml:space="preserve">
    <value>Error when processing error interceptor {0} for command {1}</value>
    <comment>{0} interceptor type name
{1} command name</comment>
  </data>
  <data name="DomainModelIsReadOnlyCantCreateElementFormat" xml:space="preserve">
    <value>Domain model is read only - Can't create element {0}</value>
    <comment>{0} serialiszation context id</comment>
  </data>
  <data name="DomainNameMismatchFormat" xml:space="preserve">
    <value>Domain name mismatch. Metadata {0} can't be added to metamodel {1}</value>
    <comment>{0} id
{1} metamodel name</comment>
  </data>
  <data name="DuplicateIndexFormat" xml:space="preserve">
    <value>Duplicate index {0}</value>
    <comment>{0} index name</comment>
  </data>
  <data name="DuplicatePropertyName" xml:space="preserve">
    <value>Duplicate property name</value>
  </data>
  <data name="ElementMustHaveAProtectedParameterlessConstructor" xml:space="preserve">
    <value>Element must have a protected parameterless constructor</value>
  </data>
  <data name="EmptyStack" xml:space="preserve">
    <value>EmptyStack</value>
  </data>
  <data name="EndElementIsNotAValidElement" xml:space="preserve">
    <value>End element is not a valid element</value>
  </data>
  <data name="ExistsButIsNotASchemaElementFormat" xml:space="preserve">
    <value>{0} exists but is not a schema element</value>
    <comment>{0} element</comment>
  </data>
  <data name="ExistsButIsNotASchemaEntityFormat" xml:space="preserve">
    <value>{0} exists but is not a schema entity</value>
    <comment>{0} element</comment>
  </data>
  <data name="ExtendedDomainNotFound" xml:space="preserve">
    <value>Extended domain not found</value>
  </data>
  <data name="FatalErrorTooManySessions" xml:space="preserve">
    <value>Fatal error - Too many sessions</value>
  </data>
  <data name="IndexInsertionFailed" xml:space="preserve">
    <value>Index insertion failed</value>
  </data>
  <data name="InvalidClassSerialization" xml:space="preserve">
    <value>Invalid class serialization</value>
  </data>
  <data name="InvalidDomainName" xml:space="preserve">
    <value>Invalid domain name</value>
  </data>
  <data name="InvalidElementFormat" xml:space="preserve">
    <value>Invalid element {0}</value>
    <comment>{0} element id</comment>
  </data>
  <data name="InvalidEndTypeForRelationship" xml:space="preserve">
    <value>Invalid end type for this relationship</value>
  </data>
  <data name="InvalidIdentity" xml:space="preserve">
    <value>Invalid identity format</value>
  </data>
  <data name="InvalidItemType" xml:space="preserve">
    <value>Invalid item type</value>
  </data>
  <data name="InvalidMetaclassForReference" xml:space="preserve">
    <value>Invalid metaclass for reference</value>
  </data>
  <data name="InvalidNameFormat" xml:space="preserve">
    <value>Invalid name : {0}</value>
    <comment>{0} name</comment>
  </data>
  <data name="InvalidPropertyNameCantBeAPropertyOfIModelElement" xml:space="preserve">
    <value>Invalid property name. Can't be a property of IModelElement.</value>
  </data>
  <data name="InvalidReference" xml:space="preserve">
    <value>Invalid reference</value>
  </data>
  <data name="InvalidSourceTypeForRelationship" xml:space="preserve">
    <value>Invalid source type for this relationship</value>
  </data>
  <data name="InvalidValue" xml:space="preserve">
    <value>Invalid value</value>
  </data>
  <data name="InvolvedModelElementsOnlyAvalaibleWhenSessionIsBeingDisposed" xml:space="preserve">
    <value>InvolvedModelElements are only avalaible when the session is being disposed. Use InvolvedElements instead.</value>
  </data>
  <data name="KeyDoesntExistFormat" xml:space="preserve">
    <value>Key doesn't exist {0}</value>
    <comment>{0} key</comment>
  </data>
  <data name="LockConflictOnResourceFormat" xml:space="preserve">
    <value>Lock conflict on resource {0}</value>
    <comment>{0} resource</comment>
  </data>
  <data name="NoSchemaFoundForThisProperty" xml:space="preserve">
    <value>No schema found for this property. You must provide a schema for this property type. Only value types can be used to define a property. To create a relationship use SchemaRelationship</value>
  </data>
  <data name="NotFound" xml:space="preserve">
    <value>Not found</value>
  </data>
  <data name="OnlyOneToManyOrManyToManyAllowedRelationshipsAllowed" xml:space="preserve">
    <value>Only one-to-many or many-to-many relationships are allowed</value>
  </data>
  <data name="PropertyNameNotValidForMetaclassFormat" xml:space="preserve">
    <value>The property name is not a valid property for metaclass {0}</value>
    <comment>{0} metaclass name</comment>
  </data>
  <data name="ReferenceHandlerCantBeUsedWithManyToManyRelationship" xml:space="preserve">
    <value>ReferenceHandler can't be used with a many-to-many relationship</value>
  </data>
  <data name="ResolveAllWorksOnlyWithSingleton" xml:space="preserve">
    <value>ResolveAll works only with singleton</value>
  </data>
  <data name="SchemaMismatch" xml:space="preserve">
    <value>Schema mismatch</value>
  </data>
  <data name="ServiceNotFoundForDomainFormat" xml:space="preserve">
    <value>Service {0} not found for domain {1}</value>
    <comment>{0} service type name
{1} domain name</comment>
  </data>
  <data name="StartElementIsNotAValidElement" xml:space="preserve">
    <value>Start element is not a valid element</value>
  </data>
  <data name="Trace_FatalErrorInEventsNotificationProcessFormat" xml:space="preserve">
    <value>Fatal error in the events notification process - {0}</value>
    <comment>{0} message</comment>
  </data>
  <data name="TryToLoadDuplicateDomainModelFormat" xml:space="preserve">
    <value>Try to load a duplicate domainModel {0}. Can happen when an active session blocks a domain unload</value>
    <comment>{0} domain model name</comment>
  </data>
  <data name="TypeFactoriesMustHaveSameBehavior" xml:space="preserve">
    <value>Type factories must have the same behavior (singleton or not)</value>
  </data>
  <data name="TypeMismatchEndElementMustBeAFormat" xml:space="preserve">
    <value>Type mismatch - End element must be a {0}</value>
    <comment>{0} schema element name</comment>
  </data>
  <data name="TypeMismatchStartElementMustBeAFormat" xml:space="preserve">
    <value>Type mismatch - Start element must be a {0}</value>
    <comment>{0} schema element name</comment>
  </data>
  <data name="UnableToCreateElementOfTypeFormat" xml:space="preserve">
    <value>Unable to create element of type {0}</value>
    <comment>{0} element type</comment>
  </data>
  <data name="UnableToCreateEntityOfTypeCtorWithIDomainModelRequiredFormat" xml:space="preserve">
    <value>Unable to create entity of type {0}. Must have a public constructor whith a IDomainModel parameter</value>
    <comment>{0} entity type</comment>
  </data>
  <data name="UnableToCreateRelationshipOfTypeRequiredCtorWithStartEndParametersFormat" xml:space="preserve">
    <value>Unable to create relationship of type {0}. Must have a public constructor whith a start and end parameter</value>
    <comment>{0} relationship type</comment>
  </data>
  <data name="UnableToRegisterServiceAfterCallToResolveOrResolveAll" xml:space="preserve">
    <value>Unable to register a service after a call to Resolve or ResolveAll</value>
  </data>
  <data name="UnknownPropertyForElementFormat" xml:space="preserve">
    <value>Unknown property {0} for element {1}</value>
    <comment>{0} property name
{1}modelElementId</comment>
  </data>
  <data name="UnknownPropertyFormat" xml:space="preserve">
    <value>Unknown property {0}</value>
    <comment>{0} property name</comment>
  </data>
  <data name="UseRemoveRelationshipToRemoveRelationship" xml:space="preserve">
    <value>Use RemoveRelationship to remove relationship</value>
  </data>
</root>